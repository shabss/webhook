# Webhook Design

## Motivation

This document describes the design of a webhook transport system between a sender (e.g github) and a receiver (e.g circle-ci). The system transports both initial webhook and the response of the hook as back to the sender.

Requirements:
1. Total message ordering is not required, but may be required on per application bases on the sender
2. Idempotency should be managed by the system. That is it should not send duplicate hook events to the receiver
3. System should be highly available and scalable

## Definitions
* **Sender**: The system initiating webhooks. E.g. github.com
* **Source**: An "application" within the Sender that originates message
* **Receiver**: The system that processes the webhook. E.g. circleci.com


## Architecture

### Components
We use **Kafka** as a queueing system because it offers following features:
1. High Availability
2. Message ordering (per partition)
3. Manual commit. Helps retrying failed operations

We use **Redis** as our primary database becasue it offers the following features:
1. Highly available
2. In memory fast access
3. Can be configured to be backed by disks

We use **Sentry** for monitoring and exception tracking

### Design

### Kafka Topics

1. **from_sender** : Sender pushes messages to this topic. There are 10 partitions. The partitioning key will be *source_id*. This will allow us to order messages from each source.
2. **to_sender**: This topic contains messages processed by the receiver and enqueued here for delivery to the sender. 
3. **to_receiver_<receiver_name>**: These topics contains messages that needs to be delivered to the receiver for processing the webooks. One topic each for a receiver with one partition each. Having a topic per receiver helps with managing rate limits and one partition helps with message ordering. 
4. **pending_from_receiver_<receiver_name>**: These topics store the events that are delivered to receiver but the response has not arrived yet. For each message in these topic we "ping" the receiver for a response and if one has arrived, we push it to "to_sender" topic.

### Databases
1. **messages**: Database that keeps track of webhook messages and to dedup duplicate messages. 
   1. PK: (source_id, message_id), values: (payload, status)
   1. (source_id, message_id) is generated by the sender and must be unique
   1. Payload is in json format and contains the information about the webhook, including the receiver name
   1. Status: can be one of:
      1. ARRIVED
      2. DELIVERED_TO_RECEIVER
      3. RESPONSE_DELIVERED_TO_SENDER (aka DONE)
1. **message_tracking**: Database that contains message tracking information. This helps with retries in case of failure. 
   1. PK: (source_id, message_id), values: (num_retries, last_sent_timestamp)
1. **message_ttl**: Database that assists with message tracking. When entries in this table expire, we need to retry the message again or fail.
   1. PK: (source_id, message_id). Add to database with TTL as configured in receiver config
1. **receiver_config**: Receiver configuration database. The data in the table is as follows:
   1. receiver_name (PK): Name of the receiver. 
   1. Rate related:
      1. rate_limit: Rate limit (msgs / window_size) that the receiver allows.
      1. window_size: Size of the window in seconds in which rate_limit applies. 
      1. current_rate: Number of messages in current window.
   1. Retry related:
      1. retry_after: number of seconds to retry after
   1. post_endpoint: endpoint to send message to
   1. status_endpoint: endpoint to check status from.


### Workers
ToDo

## Data Flow

### Forward Flow

    Sender -> [from_sender topic] -> FromSenderWorker -> [to_receiver_<receiver_name> topic] -> ToReceiverWorker -> [HTTP POST] -> Receiver 
                                          |                                                            |
                                        (dedup)                                                 (rate limit, retry)


### Backward Flow (synchronous)

    Sender <- ToSenderWorker -> [to_sender topic] <- ToReceiverWorker <- [HTTP POST response (sync)] <- Receiver 

### Backward Flow (asynchronous)

    [pending_from_receiver_<receiver_name> topic] -> ReceiverStatusAsyncWorker -> [HTTP GET] -> Receiver
                                                             .
                                                             .
                                                             .
    Sender <- ToSenderWorker -> [to_sender topic] <- ReceiverStatusAsyncWorker <- [HTTP GET] <- Receiver 
